// This file is @generated by Rafx's bindings generator; DO NOT MODIFY, open an issue in https://github.com/zeozeozeo/rafx/issues instead
#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals, unused)]
use std::ffi::c_void;
use std::os::raw::c_char;

pub mod sys {
    use std::ffi::c_void;
    use std::os::raw::c_char;

    pub const RFX_FILTER_NEAREST: i32 = 0;
    pub const RFX_FILTER_LINEAR: i32 = 1;
    pub const RFX_WRAP_REPEAT: i32 = 0;
    pub const RFX_WRAP_CLAMP: i32 = 1;
    pub const RFX_WRAP_MIRROR: i32 = 2;
    pub const RFX_TOPOLOGY_TRIANGLE_LIST: i32 = 0;
    pub const RFX_TOPOLOGY_TRIANGLE_STRIP: i32 = 1;
    pub const RFX_TOPOLOGY_POINT_LIST: i32 = 2;
    pub const RFX_TOPOLOGY_LINE_LIST: i32 = 3;
    pub const RFX_TOPOLOGY_LINE_STRIP: i32 = 4;
    pub const RFX_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: i32 = 5;
    pub const RFX_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: i32 = 6;
    pub const RFX_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY: i32 = 7;
    pub const RFX_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: i32 = 8;
    pub const RFX_TOPOLOGY_PATCH_LIST: i32 = 9;
    pub const RFX_USAGE_SHADER_RESOURCE: i32 = 1;
    pub const RFX_USAGE_SHADER_RESOURCE_STORAGE: i32 = 2;
    pub const RFX_USAGE_VERTEX_BUFFER: i32 = 4;
    pub const RFX_USAGE_INDEX_BUFFER: i32 = 8;
    pub const RFX_USAGE_CONSTANT_BUFFER: i32 = 16;
    pub const RFX_USAGE_ARGUMENT_BUFFER: i32 = 32;
    pub const RFX_USAGE_SCRATCH_BUFFER: i32 = 64;
    pub const RFX_USAGE_SHADER_BINDING_TABLE: i32 = 128;
    pub const RFX_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT: i32 = 256;
    pub const RFX_USAGE_MICROMAP_BUILD_INPUT: i32 = 512;
    pub const RFX_USAGE_TRANSFER_SRC: i32 = 1024;
    pub const RFX_USAGE_TRANSFER_DST: i32 = 2048;
    pub const RFX_STATE_UNDEFINED: i32 = 0;
    pub const RFX_STATE_PRESENT: i32 = 1;
    pub const RFX_STATE_COPY_SRC: i32 = 2;
    pub const RFX_STATE_COPY_DST: i32 = 3;
    pub const RFX_STATE_VERTEX_BUFFER: i32 = 4;
    pub const RFX_STATE_INDEX_BUFFER: i32 = 5;
    pub const RFX_STATE_INDIRECT_ARGUMENT: i32 = 6;
    pub const RFX_STATE_SHADER_READ: i32 = 7;
    pub const RFX_STATE_SHADER_WRITE: i32 = 8;
    pub const RFX_STATE_RENDER_TARGET: i32 = 9;
    pub const RFX_STATE_DEPTH_READ: i32 = 10;
    pub const RFX_STATE_DEPTH_WRITE: i32 = 11;
    pub const RFX_STATE_SCRATCH_BUFFER: i32 = 12;
    pub const RFX_STATE_RESOLVE_SRC: i32 = 13;
    pub const RFX_STATE_RESOLVE_DST: i32 = 14;
    pub const RFX_MEM_GPU_ONLY: i32 = 0;
    pub const RFX_MEM_CPU_TO_GPU: i32 = 1;
    pub const RFX_MEM_GPU_TO_CPU: i32 = 2;
    pub const RFX_FORMAT_UNKNOWN: i32 = 0;
    pub const RFX_FORMAT_RGBA8_UNORM: i32 = 1;
    pub const RFX_FORMAT_RGBA8_SRGB: i32 = 2;
    pub const RFX_FORMAT_BGRA8_UNORM: i32 = 3;
    pub const RFX_FORMAT_BGRA8_SRGB: i32 = 4;
    pub const RFX_FORMAT_R8_UINT: i32 = 5;
    pub const RFX_FORMAT_R8_SINT: i32 = 6;
    pub const RFX_FORMAT_RG8_UINT: i32 = 7;
    pub const RFX_FORMAT_RG8_SINT: i32 = 8;
    pub const RFX_FORMAT_RGBA8_UINT: i32 = 9;
    pub const RFX_FORMAT_RGBA8_SINT: i32 = 10;
    pub const RFX_FORMAT_R16_UINT: i32 = 11;
    pub const RFX_FORMAT_R16_SINT: i32 = 12;
    pub const RFX_FORMAT_R16_UNORM: i32 = 13;
    pub const RFX_FORMAT_R16_SNORM: i32 = 14;
    pub const RFX_FORMAT_RG16_UINT: i32 = 15;
    pub const RFX_FORMAT_RG16_SINT: i32 = 16;
    pub const RFX_FORMAT_RG16_UNORM: i32 = 17;
    pub const RFX_FORMAT_RG16_SNORM: i32 = 18;
    pub const RFX_FORMAT_RGBA16_UINT: i32 = 19;
    pub const RFX_FORMAT_RGBA16_SINT: i32 = 20;
    pub const RFX_FORMAT_RGBA16_UNORM: i32 = 21;
    pub const RFX_FORMAT_RGBA16_SNORM: i32 = 22;
    pub const RFX_FORMAT_R32_UINT: i32 = 23;
    pub const RFX_FORMAT_R32_SINT: i32 = 24;
    pub const RFX_FORMAT_RG32_UINT: i32 = 25;
    pub const RFX_FORMAT_RG32_SINT: i32 = 26;
    pub const RFX_FORMAT_RGB32_UINT: i32 = 27;
    pub const RFX_FORMAT_RGB32_SINT: i32 = 28;
    pub const RFX_FORMAT_RGBA32_UINT: i32 = 29;
    pub const RFX_FORMAT_RGBA32_SINT: i32 = 30;
    pub const RFX_FORMAT_R10_G10_B10_A2_UNORM: i32 = 31;
    pub const RFX_FORMAT_R10_G10_B10_A2_UINT: i32 = 32;
    pub const RFX_FORMAT_R11_G11_B10_UFLOAT: i32 = 33;
    pub const RFX_FORMAT_R9_G9_B9_E5_UFLOAT: i32 = 34;
    pub const RFX_FORMAT_BC1_RGBA_UNORM: i32 = 35;
    pub const RFX_FORMAT_BC1_RGBA_SRGB: i32 = 36;
    pub const RFX_FORMAT_BC2_RGBA_UNORM: i32 = 37;
    pub const RFX_FORMAT_BC2_RGBA_SRGB: i32 = 38;
    pub const RFX_FORMAT_BC3_RGBA_UNORM: i32 = 39;
    pub const RFX_FORMAT_BC3_RGBA_SRGB: i32 = 40;
    pub const RFX_FORMAT_BC4_R_UNORM: i32 = 41;
    pub const RFX_FORMAT_BC4_R_SNORM: i32 = 42;
    pub const RFX_FORMAT_BC5_RG_UNORM: i32 = 43;
    pub const RFX_FORMAT_BC5_RG_SNORM: i32 = 44;
    pub const RFX_FORMAT_BC6H_RGB_UFLOAT: i32 = 45;
    pub const RFX_FORMAT_BC6H_RGB_SFLOAT: i32 = 46;
    pub const RFX_FORMAT_BC7_RGBA_UNORM: i32 = 47;
    pub const RFX_FORMAT_BC7_RGBA_SRGB: i32 = 48;
    pub const RFX_FORMAT_D16_UNORM: i32 = 49;
    pub const RFX_FORMAT_D24_UNORM_S8_UINT: i32 = 50;
    pub const RFX_FORMAT_D32_FLOAT: i32 = 51;
    pub const RFX_FORMAT_D32_FLOAT_S8_UINT_X24: i32 = 52;
    pub const RFX_FORMAT_R32_FLOAT: i32 = 53;
    pub const RFX_FORMAT_RG32_FLOAT: i32 = 54;
    pub const RFX_FORMAT_RGB32_FLOAT: i32 = 55;
    pub const RFX_FORMAT_RGBA32_FLOAT: i32 = 56;
    pub const RFX_FORMAT_RGBA16_FLOAT: i32 = 57;
    pub const RFX_BLEND_FACTOR_ZERO: i32 = 0;
    pub const RFX_BLEND_FACTOR_ONE: i32 = 1;
    pub const RFX_BLEND_FACTOR_SRC_COLOR: i32 = 2;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: i32 = 3;
    pub const RFX_BLEND_FACTOR_DST_COLOR: i32 = 4;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_DST_COLOR: i32 = 5;
    pub const RFX_BLEND_FACTOR_SRC_ALPHA: i32 = 6;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: i32 = 7;
    pub const RFX_BLEND_FACTOR_DST_ALPHA: i32 = 8;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: i32 = 9;
    pub const RFX_BLEND_FACTOR_CONSTANT_COLOR: i32 = 10;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: i32 = 11;
    pub const RFX_BLEND_FACTOR_CONSTANT_ALPHA: i32 = 12;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: i32 = 13;
    pub const RFX_BLEND_FACTOR_SRC_ALPHA_SATURATE: i32 = 14;
    pub const RFX_BLEND_FACTOR_SRC1_COLOR: i32 = 15;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: i32 = 16;
    pub const RFX_BLEND_FACTOR_SRC1_ALPHA: i32 = 17;
    pub const RFX_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: i32 = 18;
    pub const RFX_BLEND_OP_ADD: i32 = 0;
    pub const RFX_BLEND_OP_SUBTRACT: i32 = 1;
    pub const RFX_BLEND_OP_REVERSE_SUBTRACT: i32 = 2;
    pub const RFX_BLEND_OP_MIN: i32 = 3;
    pub const RFX_BLEND_OP_MAX: i32 = 4;
    pub const RFX_COLOR_WRITE_RED: i32 = 1;
    pub const RFX_COLOR_WRITE_GREEN: i32 = 2;
    pub const RFX_COLOR_WRITE_BLUE: i32 = 4;
    pub const RFX_COLOR_WRITE_ALPHA: i32 = 8;
    pub const RFX_COLOR_WRITE_ALL: i32 = 15;
    pub const RFX_QUERY_TYPE_TIMESTAMP: i32 = 0;
    pub const RFX_QUERY_TYPE_OCCLUSION: i32 = 1;
    pub const RFX_CULL_NONE: i32 = 0;
    pub const RFX_CULL_BACK: i32 = 1;
    pub const RFX_CULL_FRONT: i32 = 2;
    pub const RFX_DENOISER_REBLUR_DIFFUSE: i32 = 0;
    pub const RFX_DENOISER_REBLUR_DIFFUSE_SPECULAR: i32 = 1;
    pub const RFX_DENOISER_RELAX_DIFFUSE: i32 = 2;
    pub const RFX_DENOISER_RELAX_DIFFUSE_SPECULAR: i32 = 3;
    pub const RFX_DENOISER_SIGMA_SHADOW: i32 = 4;
    pub const RFX_DENOISER_IN_VIEWZ: i32 = 0;
    pub const RFX_DENOISER_IN_MV: i32 = 1;
    pub const RFX_DENOISER_IN_NORMAL_ROUGHNESS: i32 = 2;
    pub const RFX_DENOISER_IN_DIFF_RADIANCE: i32 = 3;
    pub const RFX_DENOISER_IN_SPEC_RADIANCE: i32 = 4;
    pub const RFX_DENOISER_IN_SHADOW_DATA: i32 = 5;
    pub const RFX_DENOISER_OUT_DIFF_RADIANCE: i32 = 6;
    pub const RFX_DENOISER_OUT_SPEC_RADIANCE: i32 = 7;
    pub const RFX_DENOISER_OUT_SHADOW: i32 = 8;
    pub const RFX_DENOISER_OUT_VALIDATION: i32 = 9;
    pub const RFX_DENOISER_RESOURCE_COUNT: i32 = 10;
    pub const RFX_STENCIL_OP_KEEP: i32 = 0;
    pub const RFX_STENCIL_OP_ZERO: i32 = 1;
    pub const RFX_STENCIL_OP_REPLACE: i32 = 2;
    pub const RFX_STENCIL_OP_INCREMENT_AND_CLAMP: i32 = 3;
    pub const RFX_STENCIL_OP_DECREMENT_AND_CLAMP: i32 = 4;
    pub const RFX_STENCIL_OP_INVERT: i32 = 5;
    pub const RFX_STENCIL_OP_INCREMENT_AND_WRAP: i32 = 6;
    pub const RFX_STENCIL_OP_DECREMENT_AND_WRAP: i32 = 7;
    pub const RFX_COMPARE_NEVER: i32 = 0;
    pub const RFX_COMPARE_LESS: i32 = 1;
    pub const RFX_COMPARE_EQUAL: i32 = 2;
    pub const RFX_COMPARE_LESS_EQUAL: i32 = 3;
    pub const RFX_COMPARE_GREATER: i32 = 4;
    pub const RFX_COMPARE_NOT_EQUAL: i32 = 5;
    pub const RFX_COMPARE_GREATER_EQUAL: i32 = 6;
    pub const RFX_COMPARE_ALWAYS: i32 = 7;
    pub const RFX_SHADING_RATE_1X1: i32 = 0;
    pub const RFX_SHADING_RATE_1X2: i32 = 1;
    pub const RFX_SHADING_RATE_2X1: i32 = 2;
    pub const RFX_SHADING_RATE_2X2: i32 = 3;
    pub const RFX_SHADING_RATE_2X4: i32 = 4;
    pub const RFX_SHADING_RATE_4X2: i32 = 5;
    pub const RFX_SHADING_RATE_4X4: i32 = 6;
    pub const RFX_SHADING_RATE_COMBINER_PASSTHROUGH: i32 = 0;
    pub const RFX_SHADING_RATE_COMBINER_OVERRIDE: i32 = 1;
    pub const RFX_SHADING_RATE_COMBINER_MIN: i32 = 2;
    pub const RFX_SHADING_RATE_COMBINER_MAX: i32 = 3;
    pub const RFX_SHADING_RATE_COMBINER_SUM: i32 = 4;
    pub const RFX_UPSCALE_DISPATCH_NONE: i32 = 0;
    pub const RFX_UPSCALE_DISPATCH_RESET_HISTORY: i32 = 1;
    pub const RFX_UPSCALE_DISPATCH_USE_SPECULAR_MOTION: i32 = 2;
    pub const RFX_INDEX_UINT16: i32 = 0;
    pub const RFX_INDEX_UINT32: i32 = 1;
    pub const RFX_AS_TOP_LEVEL: i32 = 0;
    pub const RFX_AS_BOTTOM_LEVEL: i32 = 1;
    pub const RFX_BUILD_AS_NONE: i32 = 0;
    pub const RFX_BUILD_AS_PREFER_FAST_TRACE: i32 = 1;
    pub const RFX_BUILD_AS_PREFER_FAST_BUILD: i32 = 2;
    pub const RFX_BUILD_AS_ALLOW_UPDATE: i32 = 4;
    pub const RFX_BUILD_AS_ALLOW_COMPACTION: i32 = 8;
    pub const RFX_INSTANCE_NONE: i32 = 0;
    pub const RFX_INSTANCE_TRIANGLE_CULL_DISABLE: i32 = 1;
    pub const RFX_INSTANCE_TRIANGLE_FLIP_FACING: i32 = 2;
    pub const RFX_INSTANCE_FORCE_OPAQUE: i32 = 4;
    pub const RFX_INSTANCE_FORCE_NON_OPAQUE: i32 = 8;
    pub const RFX_RT_PIPELINE_NONE: i32 = 0;
    pub const RFX_RT_PIPELINE_SKIP_TRIANGLES: i32 = 1;
    pub const RFX_RT_PIPELINE_SKIP_AABBS: i32 = 2;
    pub const RFX_RT_PIPELINE_ALLOW_MICROMAPS: i32 = 4;
    pub const RFX_SHADER_GROUP_GENERAL: i32 = 0;
    pub const RFX_SHADER_GROUP_TRIANGLES: i32 = 1;
    pub const RFX_SHADER_GROUP_PROCEDURAL: i32 = 2;
    pub const RFX_TEXTURE_USAGE_SHADER_RESOURCE: i32 = 1;
    pub const RFX_TEXTURE_USAGE_RENDER_TARGET: i32 = 2;
    pub const RFX_TEXTURE_USAGE_DEPTH_STENCIL: i32 = 4;
    pub const RFX_TEXTURE_USAGE_STORAGE: i32 = 8;
    pub const RFX_MICROMAP_FORMAT_OPACITY_2_STATE: i32 = 1;
    pub const RFX_MICROMAP_FORMAT_OPACITY_4_STATE: i32 = 2;
    pub const RFX_BUILD_MICROMAP_NONE: i32 = 0;
    pub const RFX_BUILD_MICROMAP_PREFER_FAST_TRACE: i32 = 1;
    pub const RFX_BUILD_MICROMAP_PREFER_FAST_BUILD: i32 = 2;
    pub const RFX_BUILD_MICROMAP_ALLOW_COMPACTION: i32 = 4;
    pub const RFX_UPSCALER_NIS: i32 = 0;
    pub const RFX_UPSCALER_FSR: i32 = 1;
    pub const RFX_UPSCALER_XESS: i32 = 2;
    pub const RFX_UPSCALER_DLSR: i32 = 3;
    pub const RFX_UPSCALER_DLRR: i32 = 4;
    pub const RFX_UPSCALER_MODE_NATIVE: i32 = 0;
    pub const RFX_UPSCALER_MODE_ULTRA_QUALITY: i32 = 1;
    pub const RFX_UPSCALER_MODE_QUALITY: i32 = 2;
    pub const RFX_UPSCALER_MODE_BALANCED: i32 = 3;
    pub const RFX_UPSCALER_MODE_PERFORMANCE: i32 = 4;
    pub const RFX_UPSCALER_MODE_ULTRA_PERFORMANCE: i32 = 5;
    pub const RFX_UPSCALER_NONE: i32 = 0;
    pub const RFX_UPSCALER_HDR: i32 = 1;
    pub const RFX_UPSCALER_SRGB: i32 = 2;
    pub const RFX_UPSCALER_DEPTH_INVERTED: i32 = 4;
    pub const RFX_UPSCALER_DEPTH_INFINITE: i32 = 8;
    pub const RFX_UPSCALER_DEPTH_LINEAR: i32 = 16;
    pub const RFX_UPSCALER_MV_UPSCALED: i32 = 32;
    pub const RFX_UPSCALER_MV_JITTERED: i32 = 64;
    pub const RFX_BACKEND_DEFAULT: i32 = 0;
    pub const RFX_BACKEND_VULKAN: i32 = 1;
    pub const RFX_BACKEND_D3D12: i32 = 2;
    pub const RFX_BACKEND_D3D11: i32 = 3;
    pub const RFX_BACKEND_NONE: i32 = 4;
    pub const RFX_QUEUE_GRAPHICS: i32 = 0;
    pub const RFX_QUEUE_COMPUTE: i32 = 1;
    pub const RFX_QUEUE_COPY: i32 = 2;
    pub const RFX_RESOLVE_OP_AVERAGE: i32 = 0;
    pub const RFX_RESOLVE_OP_MIN: i32 = 1;
    pub const RFX_RESOLVE_OP_MAX: i32 = 2;
    pub const RFX_COPY_MODE_CLONE: i32 = 0;
    pub const RFX_COPY_MODE_COMPACT: i32 = 1;
    pub const RFX_LATENCY_MARKER_SIMULATION_START: i32 = 0;
    pub const RFX_LATENCY_MARKER_SIMULATION_END: i32 = 1;
    pub const RFX_LATENCY_MARKER_RENDER_SUBMIT_START: i32 = 2;
    pub const RFX_LATENCY_MARKER_RENDER_SUBMIT_END: i32 = 3;
    pub const RFX_LATENCY_MARKER_INPUT_SAMPLE: i32 = 4;
    pub const RFX_MOUSE_BUTTON_LEFT: i32 = 0;
    pub const RFX_MOUSE_BUTTON_RIGHT: i32 = 1;
    pub const RFX_MOUSE_BUTTON_MIDDLE: i32 = 2;
    pub const RFX_WINDOW_VSYNC: i32 = 1;
    pub const RFX_WINDOW_FULLSCREEN: i32 = 2;
    pub const RFX_WINDOW_BORDERLESS: i32 = 4;
    pub const RFX_WINDOW_ALWAYS_ACTIVE: i32 = 8;
    pub const RFX_WINDOW_NO_RESIZE: i32 = 16;
    pub const RFX_WINDOW_TRANSPARENT: i32 = 32;
    pub const RFX_WINDOW_FLOATING: i32 = 64;
    pub const RFX_WINDOW_MAXIMIZED: i32 = 128;
    pub const RFX_WINDOW_HIDDEN: i32 = 256;
    pub const RFX_WINDOW_CENTERED: i32 = 512;
    pub const RFX_WINDOW_SCALE_TO_MONITOR: i32 = 1024;
    pub const RFX_FEATURE_MESH_SHADER: i32 = 1;
    pub const RFX_FEATURE_RAY_TRACING: i32 = 2;
    pub const RFX_FEATURE_UPSCALE: i32 = 4;
    pub const RFX_FEATURE_LOW_LATENCY: i32 = 8;
    pub const RFX_CURSOR_DEFAULT: i32 = 0;
    pub const RFX_CURSOR_ARROW: i32 = 1;
    pub const RFX_CURSOR_IBEAM: i32 = 2;
    pub const RFX_CURSOR_CROSSHAIR: i32 = 3;
    pub const RFX_CURSOR_HAND: i32 = 4;
    pub const RFX_CURSOR_RESIZE_EW: i32 = 5;
    pub const RFX_CURSOR_RESIZE_H: i32 = 0;
    pub const RFX_CURSOR_RESIZE_NS: i32 = 1;
    pub const RFX_CURSOR_RESIZE_V: i32 = 0;
    pub const RFX_CURSOR_RESIZE_NWSE: i32 = 1;
    pub const RFX_CURSOR_RESIZE_NESW: i32 = 2;
    pub const RFX_CURSOR_RESIZE_ALL: i32 = 3;
    pub const RFX_CURSOR_NOT_ALLOWED: i32 = 4;
    pub const RFX_CURSOR_RESIZE_NW: i32 = 5;
    pub const RFX_CURSOR_RESIZE_N: i32 = 6;
    pub const RFX_CURSOR_RESIZE_NE: i32 = 7;
    pub const RFX_CURSOR_RESIZE_E: i32 = 8;
    pub const RFX_CURSOR_RESIZE_SE: i32 = 9;
    pub const RFX_CURSOR_RESIZE_S: i32 = 10;
    pub const RFX_CURSOR_RESIZE_SW: i32 = 11;
    pub const RFX_CURSOR_RESIZE_W: i32 = 12;
    pub const RFX_CURSOR_WAIT: i32 = 13;
    pub const RFX_CURSOR_PROGRESS: i32 = 14;
    pub const RFX_CURSOR_COUNT: i32 = 15;
    pub const RFX_KEY_SPACE: i32 = 32;
    pub const RFX_KEY_APOSTROPHE: i32 = 39;
    pub const RFX_KEY_COMMA: i32 = 44;
    pub const RFX_KEY_MINUS: i32 = 45;
    pub const RFX_KEY_PERIOD: i32 = 46;
    pub const RFX_KEY_SLASH: i32 = 47;
    pub const RFX_KEY_0: i32 = 48;
    pub const RFX_KEY_1: i32 = 49;
    pub const RFX_KEY_2: i32 = 50;
    pub const RFX_KEY_3: i32 = 51;
    pub const RFX_KEY_4: i32 = 52;
    pub const RFX_KEY_5: i32 = 53;
    pub const RFX_KEY_6: i32 = 54;
    pub const RFX_KEY_7: i32 = 55;
    pub const RFX_KEY_8: i32 = 56;
    pub const RFX_KEY_9: i32 = 57;
    pub const RFX_KEY_SEMICOLON: i32 = 59;
    pub const RFX_KEY_EQUAL: i32 = 61;
    pub const RFX_KEY_A: i32 = 65;
    pub const RFX_KEY_B: i32 = 66;
    pub const RFX_KEY_C: i32 = 67;
    pub const RFX_KEY_D: i32 = 68;
    pub const RFX_KEY_E: i32 = 69;
    pub const RFX_KEY_F: i32 = 70;
    pub const RFX_KEY_G: i32 = 71;
    pub const RFX_KEY_H: i32 = 72;
    pub const RFX_KEY_I: i32 = 73;
    pub const RFX_KEY_J: i32 = 74;
    pub const RFX_KEY_K: i32 = 75;
    pub const RFX_KEY_L: i32 = 76;
    pub const RFX_KEY_M: i32 = 77;
    pub const RFX_KEY_N: i32 = 78;
    pub const RFX_KEY_O: i32 = 79;
    pub const RFX_KEY_P: i32 = 80;
    pub const RFX_KEY_Q: i32 = 81;
    pub const RFX_KEY_R: i32 = 82;
    pub const RFX_KEY_S: i32 = 83;
    pub const RFX_KEY_T: i32 = 84;
    pub const RFX_KEY_U: i32 = 85;
    pub const RFX_KEY_V: i32 = 86;
    pub const RFX_KEY_W: i32 = 87;
    pub const RFX_KEY_X: i32 = 88;
    pub const RFX_KEY_Y: i32 = 89;
    pub const RFX_KEY_Z: i32 = 90;
    pub const RFX_KEY_LEFT_BRACKET: i32 = 91;
    pub const RFX_KEY_BACKSLASH: i32 = 92;
    pub const RFX_KEY_RIGHT_BRACKET: i32 = 93;
    pub const RFX_KEY_GRAVE_ACCENT: i32 = 96;
    pub const RFX_KEY_ESCAPE: i32 = 256;
    pub const RFX_KEY_ENTER: i32 = 257;
    pub const RFX_KEY_TAB: i32 = 258;
    pub const RFX_KEY_BACKSPACE: i32 = 259;
    pub const RFX_KEY_INSERT: i32 = 260;
    pub const RFX_KEY_DELETE: i32 = 261;
    pub const RFX_KEY_RIGHT: i32 = 262;
    pub const RFX_KEY_LEFT: i32 = 263;
    pub const RFX_KEY_DOWN: i32 = 264;
    pub const RFX_KEY_UP: i32 = 265;
    pub const RFX_KEY_PAGE_UP: i32 = 266;
    pub const RFX_KEY_PAGE_DOWN: i32 = 267;
    pub const RFX_KEY_HOME: i32 = 268;
    pub const RFX_KEY_END: i32 = 269;
    pub const RFX_KEY_CAPS_LOCK: i32 = 280;
    pub const RFX_KEY_SCROLL_LOCK: i32 = 281;
    pub const RFX_KEY_NUM_LOCK: i32 = 282;
    pub const RFX_KEY_PRINT_SCREEN: i32 = 283;
    pub const RFX_KEY_PAUSE: i32 = 284;
    pub const RFX_KEY_F1: i32 = 290;
    pub const RFX_KEY_F2: i32 = 291;
    pub const RFX_KEY_F3: i32 = 292;
    pub const RFX_KEY_F4: i32 = 293;
    pub const RFX_KEY_F5: i32 = 294;
    pub const RFX_KEY_F6: i32 = 295;
    pub const RFX_KEY_F7: i32 = 296;
    pub const RFX_KEY_F8: i32 = 297;
    pub const RFX_KEY_F9: i32 = 298;
    pub const RFX_KEY_F10: i32 = 299;
    pub const RFX_KEY_F11: i32 = 300;
    pub const RFX_KEY_F12: i32 = 301;
    pub const RFX_KEY_LEFT_SHIFT: i32 = 340;
    pub const RFX_KEY_LEFT_CONTROL: i32 = 341;
    pub const RFX_KEY_LEFT_ALT: i32 = 342;
    pub const RFX_KEY_LEFT_SUPER: i32 = 343;
    pub const RFX_KEY_RIGHT_SHIFT: i32 = 344;
    pub const RFX_KEY_RIGHT_CONTROL: i32 = 345;
    pub const RFX_KEY_RIGHT_ALT: i32 = 346;
    pub const RFX_KEY_RIGHT_SUPER: i32 = 347;
    pub const RFX_KEY_MENU: i32 = 348;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxColor {
        pub r: f32,
        pub g: f32,
        pub b: f32,
        pub a: f32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxBufferImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxTextureImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxShaderImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxPipelineImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxSamplerImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxCommandListImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxDenoiserImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxAccelerationStructureImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxShaderBindingTableImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxMicromapImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxUpscalerImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxFenceImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub struct RfxQueryPoolImpl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxBlendState {
        pub blendEnabled: bool,
        pub srcColor: RfxBlendFactor,
        pub dstColor: RfxBlendFactor,
        pub colorOp: RfxBlendOp,
        pub srcAlpha: RfxBlendFactor,
        pub dstAlpha: RfxBlendFactor,
        pub alphaOp: RfxBlendOp,
        pub writeMask: RfxColorWriteMask,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxDenoiserSettings {
        pub viewToClip: [f32; 16],
        pub viewToClipPrev: [f32; 16],
        pub worldToView: [f32; 16],
        pub worldToViewPrev: [f32; 16],
        pub denoisingRange: f32,
        pub viewZScale: f32,
        pub disocclusionThreshold: f32,
        pub enableValidation: bool,
        pub motionVectorScale: [f32; 2],
        pub isMotionVectorInWorldSpace: bool,
        pub jitter: [f32; 2],
        pub jitterPrev: [f32; 2],
        pub frameIndex: u32,
        pub resetHistory: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxVertexLayoutElement {
        pub location: u32,
        pub format: RfxFormat,
        pub offset: u32,
        pub semanticName: *const c_char,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxAttachmentDesc {
        pub format: RfxFormat,
        pub blend: RfxBlendState,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxStencilFace {
        pub compareOp: RfxCompareOp,
        pub failOp: RfxStencilOp,
        pub passOp: RfxStencilOp,
        pub depthFailOp: RfxStencilOp,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxStencilState {
        pub enabled: bool,
        pub readMask: u8,
        pub writeMask: u8,
        pub front: RfxStencilFace,
        pub back: RfxStencilFace,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxPipelineDesc {
        pub shader: RfxShader,
        pub colorFormat: RfxFormat,
        pub blendState: RfxBlendState,
        pub attachments: *const RfxAttachmentDesc,
        pub attachmentCount: u32,
        pub depthFormat: RfxFormat,
        pub topology: RfxTopology,
        pub patchControlPoints: u32,
        pub cullMode: RfxCullMode,
        pub sampleCount: i32,
        pub depthTest: bool,
        pub depthWrite: bool,
        pub depthCompareOp: RfxCompareOp,
        pub depthBiasConstant: f32,
        pub depthBiasClamp: f32,
        pub depthBiasSlope: f32,
        pub depthBoundsTest: bool,
        pub stencil: RfxStencilState,
        pub shadingRate: bool,
        pub wireframe: bool,
        pub viewMask: u32,
        pub vertexLayout: *const RfxVertexLayoutElement,
        pub vertexLayoutCount: i32,
        pub vertexStride: i32,
        pub vsEntryPoint: *const c_char,
        pub psEntryPoint: *const c_char,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxComputePipelineDesc {
        pub shader: RfxShader,
        pub entryPoint: *const c_char,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxGpuTimestamp {
        pub name: *const c_char,
        pub microseconds: f32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxGeometryTriangles {
        pub vertexBuffer: RfxBuffer,
        pub vertexOffset: u64,
        pub vertexCount: u32,
        pub vertexStride: u32,
        pub vertexFormat: RfxFormat,
        pub indexBuffer: RfxBuffer,
        pub indexOffset: u64,
        pub indexCount: u32,
        pub indexType: RfxIndexType,
        pub transformBuffer: RfxBuffer,
        pub transformOffset: u64,
        pub micromap: RfxMicromap,
        pub micromapIndexBuffer: RfxBuffer,
        pub micromapIndexOffset: u64,
        pub micromapIndexType: RfxIndexType,
        pub micromapBaseTriangle: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxGeometryAABBs {
        pub aabbBuffer: RfxBuffer,
        pub offset: u64,
        pub count: u32,
        pub stride: u32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union RfxGeometryDesc_Data {
        pub triangles: RfxGeometryTriangles,
        pub aabbs: RfxGeometryAABBs,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct RfxGeometryDesc {
        pub isAABB: bool,
        pub opaque: bool,
        pub data: RfxGeometryDesc_Data,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxAccelerationStructureDesc {
        pub r#type: RfxAccelerationStructureType,
        pub flags: RfxBuildASFlags,
        pub count: u32,
        pub geometries: *const RfxGeometryDesc,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxInstance {
        pub transform: [[f32; 4]; 3],
        pub instanceId: u32,
        pub mask: u32,
        pub instanceContributionToHitGroupIndex: u32,
        pub flags: RfxInstanceFlags,
        pub blas: RfxAccelerationStructure,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxShaderGroup {
        pub r#type: RfxShaderGroupType,
        pub generalShader: *const c_char,
        pub closestHitShader: *const c_char,
        pub anyHitShader: *const c_char,
        pub intersectionShader: *const c_char,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxRayTracingPipelineDesc {
        pub shader: RfxShader,
        pub groups: *const RfxShaderGroup,
        pub groupCount: u32,
        pub maxRecursionDepth: u32,
        pub maxPayloadSize: u32,
        pub maxAttributeSize: u32,
        pub flags: RfxRayTracingPipelineFlags,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxTraceRaysDesc {
        pub sbt: RfxShaderBindingTable,
        pub rayGenIndex: u32,
        pub missIndex: u32,
        pub missCount: u32,
        pub hitIndex: u32,
        pub hitCount: u32,
        pub callableIndex: u32,
        pub callableCount: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxTextureDesc {
        pub width: u32,
        pub height: u32,
        pub depth: u32,
        pub mipLevels: u32,
        pub arrayLayers: u32,
        pub format: RfxFormat,
        pub sampleCount: i32,
        pub usage: RfxTextureUsageFlags,
        pub initialData: *const c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxMicromapUsage {
        pub count: u32,
        pub subdivisionLevel: u16,
        pub format: RfxMicromapFormat,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxMicromapDesc {
        pub usages: *const RfxMicromapUsage,
        pub usageCount: u32,
        pub flags: RfxBuildMicromapFlags,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxBuildMicromapDesc {
        pub dst: RfxMicromap,
        pub data: RfxBuffer,
        pub dataOffset: u64,
        pub triangleIndices: RfxBuffer,
        pub triangleIndicesOffset: u64,
        pub scratch: RfxBuffer,
        pub scratchOffset: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxUpscalerDesc {
        pub r#type: RfxUpscalerType,
        pub mode: RfxUpscalerMode,
        pub flags: RfxUpscalerFlags,
        pub outputWidth: u32,
        pub outputHeight: u32,
        pub preset: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxUpscalerProps {
        pub scalingFactor: f32,
        pub mipBias: f32,
        pub renderWidth: u32,
        pub renderHeight: u32,
        pub outputWidth: u32,
        pub outputHeight: u32,
        pub jitterPhaseCount: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxUpscaleDesc {
        pub input: RfxTexture,
        pub output: RfxTexture,
        pub depth: RfxTexture,
        pub motionVectors: RfxTexture,
        pub exposure: RfxTexture,
        pub reactive: RfxTexture,
        pub normalRoughness: RfxTexture,
        pub diffuseAlbedo: RfxTexture,
        pub specularAlbedo: RfxTexture,
        pub specularMvOrHitT: RfxTexture,
        pub sss: RfxTexture,
        pub sharpness: f32,
        pub jitter: [f32; 2],
        pub motionVectorScale: [f32; 2],
        pub dispatchFlags: RfxUpscaleDispatchFlags,
        pub zNear: f32,
        pub zFar: f32,
        pub verticalFov: f32,
        pub viewSpaceToMetersFactor: f32,
        pub viewToClip: [f32; 16],
        pub worldToView: [f32; 16],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxSampleLocation {
        pub x: i8,
        pub y: i8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxLatencyReport {
        pub inputSampleTimeUs: u64,
        pub simulationStartTimeUs: u64,
        pub simulationEndTimeUs: u64,
        pub renderSubmitStartTimeUs: u64,
        pub renderSubmitEndTimeUs: u64,
        pub presentStartTimeUs: u64,
        pub presentEndTimeUs: u64,
        pub driverStartTimeUs: u64,
        pub driverEndTimeUs: u64,
        pub osRenderQueueStartTimeUs: u64,
        pub osRenderQueueEndTimeUs: u64,
        pub gpuRenderStartTimeUs: u64,
        pub gpuRenderEndTimeUs: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RfxImGuiDrawData {
        pub drawLists: *const c_void,
        pub drawListCount: u32,
        pub textures: *const c_void,
        pub textureCount: u32,
        pub displayWidth: f32,
        pub displayHeight: f32,
        pub hdrScale: f32,
        pub linearColor: bool,
    }
    pub type RfxBuffer = *mut RfxBufferImpl;
    pub type RfxTexture = *mut RfxTextureImpl;
    pub type RfxShader = *mut RfxShaderImpl;
    pub type RfxPipeline = *mut RfxPipelineImpl;
    pub type RfxSampler = *mut RfxSamplerImpl;
    pub type RfxCommandList = *mut RfxCommandListImpl;
    pub type RfxDenoiser = *mut RfxDenoiserImpl;
    pub type RfxAccelerationStructure = *mut RfxAccelerationStructureImpl;
    pub type RfxShaderBindingTable = *mut RfxShaderBindingTableImpl;
    pub type RfxMicromap = *mut RfxMicromapImpl;
    pub type RfxUpscaler = *mut RfxUpscalerImpl;
    pub type RfxFence = *mut RfxFenceImpl;
    pub type RfxQueryPool = *mut RfxQueryPoolImpl;
    pub type RfxFilter = u32;
    pub type RfxAddressMode = u32;
    pub type RfxTopology = u32;
    pub type RfxBufferUsageFlags = u32;
    pub type RfxResourceState = u32;
    pub type RfxMemoryType = u32;
    pub type RfxFormat = u32;
    pub type RfxBlendFactor = u32;
    pub type RfxBlendOp = u32;
    pub type RfxColorWriteMask = u8;
    pub type RfxQueryType = u32;
    pub type RfxCullMode = u32;
    pub type RfxDenoiserType = u32;
    pub type RfxDenoiserResourceId = u32;
    pub type RfxStencilOp = u32;
    pub type RfxCompareOp = u32;
    pub type RfxShadingRate = u32;
    pub type RfxShadingRateCombiner = u32;
    pub type RfxUpscaleDispatchFlags = u32;
    pub type RfxIndexType = u32;
    pub type RfxAccelerationStructureType = u32;
    pub type RfxBuildASFlags = u32;
    pub type RfxInstanceFlags = u32;
    pub type RfxRayTracingPipelineFlags = u32;
    pub type RfxShaderGroupType = u32;
    pub type RfxTextureUsageFlags = u8;
    pub type RfxMicromapFormat = u32;
    pub type RfxBuildMicromapFlags = u32;
    pub type RfxUpscalerType = u32;
    pub type RfxUpscalerMode = u32;
    pub type RfxUpscalerFlags = u32;
    pub type RfxBackend = u8;
    pub type RfxQueueType = u32;
    pub type RfxResolveOp = u32;
    pub type RfxCopyMode = u32;
    pub type RfxLatencyMarker = u32;
    pub type RfxMouseButton = u8;
    pub type RfxWindowFlags = u32;
    pub type RfxFeatureSupportFlags = u32;
    pub type RfxCursorType = u32;
    pub type RfxKey = u32;

    unsafe extern "C" {
        pub fn rfxRequestBackend(backend: RfxBackend, enableValidation: bool);
        pub fn rfxOpenWindow(title: *const c_char, width: i32, height: i32) -> bool;
        pub fn rfxSupportsFeatures(features: RfxFeatureSupportFlags) -> bool;
        pub fn rfxGetSupportedFeatures() -> RfxFeatureSupportFlags;
        pub fn rfxSetSampleCount(count: i32);
        pub fn rfxSetAnisotropy(level: i32);
        pub fn rfxSetWindowFlags(flags: RfxWindowFlags);
        pub fn rfxEnableWindowFlags(flags: RfxWindowFlags);
        pub fn rfxDisableWindowFlags(flags: RfxWindowFlags);
        pub fn rfxToggleWindowFlags(flags: RfxWindowFlags);
        pub fn rfxHasWindowFlags(flags: RfxWindowFlags) -> bool;
        pub fn rfxWindowShouldClose() -> bool;
        pub fn rfxPollInputEvents();
        pub fn rfxGetWindowSize(width: *mut i32, height: *mut i32);
        pub fn rfxGetWindowWidth() -> i32;
        pub fn rfxGetWindowHeight() -> i32;
        pub fn rfxGetTime() -> f64;
        pub fn rfxGetDeltaTime() -> f32;
        pub fn rfxGetFrameIndex() -> u32;
        pub fn rfxIsKeyDown(key: RfxKey) -> bool;
        pub fn rfxIsKeyPressed(key: RfxKey) -> bool;
        pub fn rfxIsKeyReleased(key: RfxKey) -> bool;
        pub fn rfxIsMouseButtonDown(button: RfxMouseButton) -> bool;
        pub fn rfxIsMouseButtonPressed(button: RfxMouseButton) -> bool;
        pub fn rfxIsMouseButtonReleased(button: RfxMouseButton) -> bool;
        pub fn rfxGetMousePos(x: *mut f32, y: *mut f32);
        pub fn rfxGetMouseDelta(x: *mut f32, y: *mut f32);
        pub fn rfxSetMouseCursorVisible(visible: bool);
        pub fn rfxSetMouseCursor(cursor: RfxCursorType);
        pub fn rfxCreateBuffer(
            size: usize,
            stride: usize,
            usage: RfxBufferUsageFlags,
            memType: RfxMemoryType,
            initialData: *const c_void,
        ) -> RfxBuffer;
        pub fn rfxDestroyBuffer(buffer: RfxBuffer);
        pub fn rfxMapBuffer(buffer: RfxBuffer) -> *mut c_void;
        pub fn rfxUnmapBuffer(buffer: RfxBuffer);
        pub fn rfxGetBufferId(buffer: RfxBuffer) -> u32;
        pub fn rfxCreateTexture(
            width: i32,
            height: i32,
            format: RfxFormat,
            sampleCount: i32,
            usage: RfxTextureUsageFlags,
            initialData: *const c_void,
        ) -> RfxTexture;
        pub fn rfxCreateTextureEx(desc: *const RfxTextureDesc) -> RfxTexture;
        pub fn rfxCreateTextureView(
            original: RfxTexture,
            format: RfxFormat,
            mip: u32,
            mipCount: u32,
            layer: u32,
            layerCount: u32,
        ) -> RfxTexture;
        pub fn rfxDestroyTexture(texture: RfxTexture);
        pub fn rfxGetTextureId(texture: RfxTexture) -> u32;
        pub fn rfxGetTextureDescriptor(texture: RfxTexture) -> *mut c_void;
        pub fn rfxGetSwapChainFormat() -> RfxFormat;
        pub fn rfxGetBackbufferTexture() -> RfxTexture;
        pub fn rfxCreateSampler(filter: RfxFilter, addressMode: RfxAddressMode) -> RfxSampler;
        pub fn rfxDestroySampler(sampler: RfxSampler);
        pub fn rfxCompileShader(
            filepath: *const c_char,
            defines: *const c_char,
            numDefines: i32,
            includeDirs: *const c_char,
            numIncludeDirs: i32,
        ) -> RfxShader;
        pub fn rfxCompileShaderMem(
            source: *const c_char,
            defines: *const c_char,
            numDefines: i32,
            includeDirs: *const c_char,
            numIncludeDirs: i32,
        ) -> RfxShader;
        pub fn rfxDestroyShader(shader: RfxShader);
        pub fn rfxCreatePipeline(desc: *const RfxPipelineDesc) -> RfxPipeline;
        pub fn rfxDestroyPipeline(pipeline: RfxPipeline);
        pub fn rfxCreateComputePipeline(desc: *const RfxComputePipelineDesc) -> RfxPipeline;
        pub fn rfxSetBufferName(buffer: RfxBuffer, name: *const c_char);
        pub fn rfxSetTextureName(texture: RfxTexture, name: *const c_char);
        pub fn rfxSetPipelineName(pipeline: RfxPipeline, name: *const c_char);
        pub fn rfxGetCommandList() -> RfxCommandList;
        pub fn rfxCreateCommandList(queueType: RfxQueueType) -> RfxCommandList;
        pub fn rfxDestroyCommandList(cmd: RfxCommandList);
        pub fn rfxBeginCommandList(cmd: RfxCommandList);
        pub fn rfxEndCommandList(cmd: RfxCommandList);
        pub fn rfxBeginFrame();
        pub fn rfxEndFrame();
        pub fn rfxCreateFence(initialValue: u64) -> RfxFence;
        pub fn rfxDestroyFence(fence: RfxFence);
        pub fn rfxWaitFence(fence: RfxFence, value: u64);
        pub fn rfxGetFenceValue(fence: RfxFence) -> u64;
        pub fn rfxSubmitCommandListAsync(
            cmd: RfxCommandList,
            waitFences: *mut RfxFence,
            waitValues: *mut u64,
            waitCount: u32,
            signalFences: *mut RfxFence,
            signalValues: *mut u64,
            signalCount: u32,
        );
        pub fn rfxCmdBeginSwapchainRenderPass(
            cmd: RfxCommandList,
            depthStencilFormat: RfxFormat,
            clearColor: RfxColor,
        );
        pub fn rfxCmdBeginRenderPass(
            cmd: RfxCommandList,
            colors: *mut RfxTexture,
            colorCount: u32,
            depth: RfxTexture,
            clearColor: RfxColor,
            viewMask: u32,
        );
        pub fn rfxCmdEndRenderPass(cmd: RfxCommandList);
        pub fn rfxCmdClear(cmd: RfxCommandList, color: RfxColor);
        pub fn rfxCmdBindPipeline(cmd: RfxCommandList, pipeline: RfxPipeline);
        pub fn rfxCmdSetViewports(cmd: RfxCommandList, viewports: *mut f32, count: u32);
        pub fn rfxCmdSetScissor(cmd: RfxCommandList, x: i32, y: i32, width: i32, height: i32);
        pub fn rfxCmdSetBlendConstants(cmd: RfxCommandList, color: RfxColor);
        pub fn rfxCmdSetStencilReference(cmd: RfxCommandList, frontRef: u8, backRef: u8);
        pub fn rfxCmdSetDepthBounds(cmd: RfxCommandList, minBound: f32, maxBound: f32);
        pub fn rfxCmdSetDepthBias(cmd: RfxCommandList, constant: f32, clamp: f32, slope: f32);
        pub fn rfxCmdSetShadingRate(
            cmd: RfxCommandList,
            rate: RfxShadingRate,
            primitiveCombiner: RfxShadingRateCombiner,
            attachmentCombiner: RfxShadingRateCombiner,
        );
        pub fn rfxCmdSetSampleLocations(
            cmd: RfxCommandList,
            locations: *const RfxSampleLocation,
            locationCount: u32,
            sampleCount: u32,
        );
        pub fn rfxCmdBindVertexBuffer(cmd: RfxCommandList, buffer: RfxBuffer);
        pub fn rfxCmdBindIndexBuffer(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            indexType: RfxIndexType,
        );
        pub fn rfxCmdPushConstants(cmd: RfxCommandList, data: *const c_void, size: usize);
        pub fn rfxCmdDraw(cmd: RfxCommandList, vertexCount: u32, instanceCount: u32);
        pub fn rfxCmdDrawIndexed(cmd: RfxCommandList, indexCount: u32, instanceCount: u32);
        pub fn rfxCmdDispatch(cmd: RfxCommandList, x: u32, y: u32, z: u32);
        pub fn rfxCmdDrawIndirect(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            offset: usize,
            drawCount: u32,
            stride: u32,
        );
        pub fn rfxCmdDrawIndexedIndirect(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            offset: usize,
            drawCount: u32,
            stride: u32,
        );
        pub fn rfxCmdDispatchIndirect(cmd: RfxCommandList, buffer: RfxBuffer, offset: usize);
        pub fn rfxCmdDrawMeshTasks(cmd: RfxCommandList, x: u32, y: u32, z: u32);
        pub fn rfxCmdDrawMeshTasksIndirect(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            offset: usize,
            drawCount: u32,
            stride: u32,
        );
        pub fn rfxCmdDrawIndirectCount(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            offset: usize,
            countBuffer: RfxBuffer,
            countBufferOffset: usize,
            maxDrawCount: u32,
            stride: u32,
        );
        pub fn rfxCmdDrawIndexedIndirectCount(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            offset: usize,
            countBuffer: RfxBuffer,
            countBufferOffset: usize,
            maxDrawCount: u32,
            stride: u32,
        );
        pub fn rfxCmdDrawMeshTasksIndirectCount(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            offset: usize,
            countBuffer: RfxBuffer,
            countBufferOffset: usize,
            maxDrawCount: u32,
            stride: u32,
        );
        pub fn rfxCmdCopyBuffer(
            cmd: RfxCommandList,
            src: RfxBuffer,
            srcOffset: usize,
            dst: RfxBuffer,
            dstOffset: usize,
            size: usize,
        );
        pub fn rfxCmdCopyTexture(cmd: RfxCommandList, src: RfxTexture, dst: RfxTexture);
        pub fn rfxCmdUploadTexture(
            cmd: RfxCommandList,
            dst: RfxTexture,
            data: *const c_void,
            mip: u32,
            layer: u32,
        );
        pub fn rfxCmdReadbackTextureToBuffer(
            cmd: RfxCommandList,
            src: RfxTexture,
            dst: RfxBuffer,
            dstOffset: u64,
        );
        pub fn rfxCmdZeroBuffer(cmd: RfxCommandList, buffer: RfxBuffer, offset: usize, size: usize);
        pub fn rfxCmdClearStorageBuffer(cmd: RfxCommandList, buffer: RfxBuffer, value: u32);
        pub fn rfxCmdClearStorageTexture(cmd: RfxCommandList, texture: RfxTexture, value: RfxColor);
        pub fn rfxCmdResolveTexture(
            cmd: RfxCommandList,
            dst: RfxTexture,
            src: RfxTexture,
            op: RfxResolveOp,
        );
        pub fn rfxCmdCopyMicromap(
            cmd: RfxCommandList,
            dst: RfxMicromap,
            src: RfxMicromap,
            mode: RfxCopyMode,
        );
        pub fn rfxCmdCopyAccelerationStructure(
            cmd: RfxCommandList,
            dst: RfxAccelerationStructure,
            src: RfxAccelerationStructure,
            mode: RfxCopyMode,
        );
        pub fn rfxCmdTransitionBuffer(
            cmd: RfxCommandList,
            buffer: RfxBuffer,
            state: RfxResourceState,
        );
        pub fn rfxCmdTransitionTexture(
            cmd: RfxCommandList,
            texture: RfxTexture,
            state: RfxResourceState,
        );
        pub fn rfxBeginEvent(name: *const c_char);
        pub fn rfxEndEvent();
        pub fn rfxMarker(name: *const c_char);
        pub fn rfxCmdBeginEvent(cmd: RfxCommandList, name: *const c_char);
        pub fn rfxCmdEndEvent(cmd: RfxCommandList);
        pub fn rfxCmdMarker(cmd: RfxCommandList, name: *const c_char);
        pub fn rfxCmdBeginProfile(cmd: RfxCommandList, name: *const c_char);
        pub fn rfxCmdEndProfile(cmd: RfxCommandList);
        pub fn rfxGetGpuTimestamps(outTimestamps: *mut RfxGpuTimestamp, maxCount: u32) -> u32;
        pub fn rfxCreateQueryPool(r#type: RfxQueryType, capacity: u32) -> RfxQueryPool;
        pub fn rfxDestroyQueryPool(pool: RfxQueryPool);
        pub fn rfxCmdResetQueries(cmd: RfxCommandList, pool: RfxQueryPool, offset: u32, count: u32);
        pub fn rfxCmdBeginQuery(cmd: RfxCommandList, pool: RfxQueryPool, queryIndex: u32);
        pub fn rfxCmdEndQuery(cmd: RfxCommandList, pool: RfxQueryPool, queryIndex: u32);
        pub fn rfxCmdCopyQueries(
            cmd: RfxCommandList,
            pool: RfxQueryPool,
            offset: u32,
            count: u32,
            dstBuffer: RfxBuffer,
            dstOffset: u64,
        );
        pub fn rfxSetLowLatencyMode(enabled: bool, boost: bool);
        pub fn rfxLatencySleep();
        pub fn rfxSetLatencyMarker(marker: RfxLatencyMarker);
        pub fn rfxGetLatencyReport(outReport: *mut RfxLatencyReport) -> bool;
        pub fn rfxInitImGui() -> bool;
        pub fn rfxShutdownImGui();
        pub fn rfxCmdDrawImGui(cmd: RfxCommandList, data: *const RfxImGuiDrawData);
        pub fn rfxCreateDenoiser(r#type: RfxDenoiserType, width: i32, height: i32) -> RfxDenoiser;
        pub fn rfxDestroyDenoiser(denoiser: RfxDenoiser);
        pub fn rfxCmdDenoise(
            cmd: RfxCommandList,
            denoiser: RfxDenoiser,
            settings: *const RfxDenoiserSettings,
            resources: *mut RfxTexture,
            resourceCount: u32,
        );
        pub fn rfxCreateAccelerationStructure(
            desc: *const RfxAccelerationStructureDesc,
        ) -> RfxAccelerationStructure;
        pub fn rfxDestroyAccelerationStructure(r#as: RfxAccelerationStructure);
        pub fn rfxGetAccelerationStructureId(r#as: RfxAccelerationStructure) -> u32;
        pub fn rfxGetAccelerationStructureScratchSize(r#as: RfxAccelerationStructure) -> u64;
        pub fn rfxCmdWriteAccelerationStructureSize(
            cmd: RfxCommandList,
            asArray: *mut RfxAccelerationStructure,
            count: u32,
            pool: RfxQueryPool,
            queryOffset: u32,
        );
        pub fn rfxCreateRayTracingPipeline(desc: *const RfxRayTracingPipelineDesc) -> RfxPipeline;
        pub fn rfxCreateShaderBindingTable(pipeline: RfxPipeline) -> RfxShaderBindingTable;
        pub fn rfxDestroyShaderBindingTable(sbt: RfxShaderBindingTable);
        pub fn rfxCmdBuildAccelerationStructure(
            cmd: RfxCommandList,
            dst: RfxAccelerationStructure,
            scratch: RfxBuffer,
            instanceBuffer: RfxBuffer,
        );
        pub fn rfxCmdUploadInstances(
            cmd: RfxCommandList,
            dstBuffer: RfxBuffer,
            instances: *const RfxInstance,
            instanceCount: u32,
        );
        pub fn rfxCmdTraceRays(
            cmd: RfxCommandList,
            desc: *const RfxTraceRaysDesc,
            width: u32,
            height: u32,
            depth: u32,
        );
        pub fn rfxCmdDispatchRaysIndirect(
            cmd: RfxCommandList,
            desc: *const RfxTraceRaysDesc,
            argsBuffer: RfxBuffer,
            argsOffset: u64,
        );
        pub fn rfxCreateMicromap(desc: *const RfxMicromapDesc) -> RfxMicromap;
        pub fn rfxDestroyMicromap(micromap: RfxMicromap);
        pub fn rfxGetMicromapScratchSize(micromap: RfxMicromap) -> u64;
        pub fn rfxCmdBuildMicromaps(cmd: RfxCommandList, desc: *const RfxBuildMicromapDesc);
        pub fn rfxIsUpscalerSupported(r#type: RfxUpscalerType) -> bool;
        pub fn rfxCreateUpscaler(desc: *const RfxUpscalerDesc) -> RfxUpscaler;
        pub fn rfxDestroyUpscaler(upscaler: RfxUpscaler);
        pub fn rfxGetUpscalerProps(upscaler: RfxUpscaler, outProps: *mut RfxUpscalerProps);
        pub fn rfxCmdUpscale(
            cmd: RfxCommandList,
            upscaler: RfxUpscaler,
            desc: *const RfxUpscaleDesc,
        );
    }
}

//
// Typedefs
//
pub type Filter = sys::RfxFilter;
pub type AddressMode = sys::RfxAddressMode;
pub type Topology = sys::RfxTopology;
pub type BufferUsageFlags = sys::RfxBufferUsageFlags;
pub type ResourceState = sys::RfxResourceState;
pub type MemoryType = sys::RfxMemoryType;
pub type Format = sys::RfxFormat;
pub type BlendFactor = sys::RfxBlendFactor;
pub type BlendOp = sys::RfxBlendOp;
pub type ColorWriteMask = sys::RfxColorWriteMask;
pub type QueryType = sys::RfxQueryType;
pub type CullMode = sys::RfxCullMode;
pub type DenoiserType = sys::RfxDenoiserType;
pub type DenoiserResourceId = sys::RfxDenoiserResourceId;
pub type StencilOp = sys::RfxStencilOp;
pub type CompareOp = sys::RfxCompareOp;
pub type ShadingRate = sys::RfxShadingRate;
pub type ShadingRateCombiner = sys::RfxShadingRateCombiner;
pub type UpscaleDispatchFlags = sys::RfxUpscaleDispatchFlags;
pub type IndexType = sys::RfxIndexType;
pub type AccelerationStructureType = sys::RfxAccelerationStructureType;
pub type BuildASFlags = sys::RfxBuildASFlags;
pub type InstanceFlags = sys::RfxInstanceFlags;
pub type RayTracingPipelineFlags = sys::RfxRayTracingPipelineFlags;
pub type ShaderGroupType = sys::RfxShaderGroupType;
pub type TextureUsageFlags = sys::RfxTextureUsageFlags;
pub type MicromapFormat = sys::RfxMicromapFormat;
pub type BuildMicromapFlags = sys::RfxBuildMicromapFlags;
pub type UpscalerType = sys::RfxUpscalerType;
pub type UpscalerMode = sys::RfxUpscalerMode;
pub type UpscalerFlags = sys::RfxUpscalerFlags;
pub type Backend = sys::RfxBackend;
pub type QueueType = sys::RfxQueueType;
pub type ResolveOp = sys::RfxResolveOp;
pub type CopyMode = sys::RfxCopyMode;
pub type LatencyMarker = sys::RfxLatencyMarker;
pub type MouseButton = sys::RfxMouseButton;
pub type WindowFlags = sys::RfxWindowFlags;
pub type FeatureSupportFlags = sys::RfxFeatureSupportFlags;
pub type CursorType = sys::RfxCursorType;
pub type Key = sys::RfxKey;

//
// Enums
//
//
// Handles and structs
//
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructure(pub sys::RfxAccelerationStructure);
impl AccelerationStructure {
    pub fn as_raw(&self) -> sys::RfxAccelerationStructure {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccelerationStructureImpl(pub sys::RfxAccelerationStructureImpl);
impl AccelerationStructureImpl {
    pub fn as_raw(&self) -> sys::RfxAccelerationStructureImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Buffer(pub sys::RfxBuffer);
impl Buffer {
    pub fn as_raw(&self) -> sys::RfxBuffer {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct BufferImpl(pub sys::RfxBufferImpl);
impl BufferImpl {
    pub fn as_raw(&self) -> sys::RfxBufferImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandList(pub sys::RfxCommandList);
impl CommandList {
    pub fn as_raw(&self) -> sys::RfxCommandList {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct CommandListImpl(pub sys::RfxCommandListImpl);
impl CommandListImpl {
    pub fn as_raw(&self) -> sys::RfxCommandListImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Denoiser(pub sys::RfxDenoiser);
impl Denoiser {
    pub fn as_raw(&self) -> sys::RfxDenoiser {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct DenoiserImpl(pub sys::RfxDenoiserImpl);
impl DenoiserImpl {
    pub fn as_raw(&self) -> sys::RfxDenoiserImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Fence(pub sys::RfxFence);
impl Fence {
    pub fn as_raw(&self) -> sys::RfxFence {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FenceImpl(pub sys::RfxFenceImpl);
impl FenceImpl {
    pub fn as_raw(&self) -> sys::RfxFenceImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Micromap(pub sys::RfxMicromap);
impl Micromap {
    pub fn as_raw(&self) -> sys::RfxMicromap {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct MicromapImpl(pub sys::RfxMicromapImpl);
impl MicromapImpl {
    pub fn as_raw(&self) -> sys::RfxMicromapImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Pipeline(pub sys::RfxPipeline);
impl Pipeline {
    pub fn as_raw(&self) -> sys::RfxPipeline {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct PipelineImpl(pub sys::RfxPipelineImpl);
impl PipelineImpl {
    pub fn as_raw(&self) -> sys::RfxPipelineImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryPool(pub sys::RfxQueryPool);
impl QueryPool {
    pub fn as_raw(&self) -> sys::RfxQueryPool {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct QueryPoolImpl(pub sys::RfxQueryPoolImpl);
impl QueryPoolImpl {
    pub fn as_raw(&self) -> sys::RfxQueryPoolImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Sampler(pub sys::RfxSampler);
impl Sampler {
    pub fn as_raw(&self) -> sys::RfxSampler {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct SamplerImpl(pub sys::RfxSamplerImpl);
impl SamplerImpl {
    pub fn as_raw(&self) -> sys::RfxSamplerImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Shader(pub sys::RfxShader);
impl Shader {
    pub fn as_raw(&self) -> sys::RfxShader {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderBindingTable(pub sys::RfxShaderBindingTable);
impl ShaderBindingTable {
    pub fn as_raw(&self) -> sys::RfxShaderBindingTable {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderBindingTableImpl(pub sys::RfxShaderBindingTableImpl);
impl ShaderBindingTableImpl {
    pub fn as_raw(&self) -> sys::RfxShaderBindingTableImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ShaderImpl(pub sys::RfxShaderImpl);
impl ShaderImpl {
    pub fn as_raw(&self) -> sys::RfxShaderImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Texture(pub sys::RfxTexture);
impl Texture {
    pub fn as_raw(&self) -> sys::RfxTexture {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct TextureImpl(pub sys::RfxTextureImpl);
impl TextureImpl {
    pub fn as_raw(&self) -> sys::RfxTextureImpl {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Upscaler(pub sys::RfxUpscaler);
impl Upscaler {
    pub fn as_raw(&self) -> sys::RfxUpscaler {
        self.0
    }
}

#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct UpscalerImpl(pub sys::RfxUpscalerImpl);
impl UpscalerImpl {
    pub fn as_raw(&self) -> sys::RfxUpscalerImpl {
        self.0
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Color {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
impl Default for Color {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlendState {
    pub blend_enabled: bool,
    pub src_color: BlendFactor,
    pub dst_color: BlendFactor,
    pub color_op: BlendOp,
    pub src_alpha: BlendFactor,
    pub dst_alpha: BlendFactor,
    pub alpha_op: BlendOp,
    pub write_mask: ColorWriteMask,
}
impl Default for BlendState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DenoiserSettings {
    pub view_to_clip: [f32; 16],
    pub view_to_clip_prev: [f32; 16],
    pub world_to_view: [f32; 16],
    pub world_to_view_prev: [f32; 16],
    pub denoising_range: f32,
    pub view_z_scale: f32,
    pub disocclusion_threshold: f32,
    pub enable_validation: bool,
    pub motion_vector_scale: [f32; 2],
    pub is_motion_vector_in_world_space: bool,
    pub jitter: [f32; 2],
    pub jitter_prev: [f32; 2],
    pub frame_index: u32,
    pub reset_history: bool,
}
impl Default for DenoiserSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VertexLayoutElement {
    pub location: u32,
    pub format: Format,
    pub offset: u32,
    pub semantic_name: *const c_char,
}
impl Default for VertexLayoutElement {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachmentDesc {
    pub format: Format,
    pub blend: BlendState,
}
impl Default for AttachmentDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StencilFace {
    pub compare_op: CompareOp,
    pub fail_op: StencilOp,
    pub pass_op: StencilOp,
    pub depth_fail_op: StencilOp,
}
impl Default for StencilFace {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StencilState {
    pub enabled: bool,
    pub read_mask: u8,
    pub write_mask: u8,
    pub front: StencilFace,
    pub back: StencilFace,
}
impl Default for StencilState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDesc {
    pub shader: Shader,
    pub color_format: Format,
    pub blend_state: BlendState,
    pub attachments: *const AttachmentDesc,
    pub attachment_count: u32,
    pub depth_format: Format,
    pub topology: Topology,
    pub patch_control_points: u32,
    pub cull_mode: CullMode,
    pub sample_count: i32,
    pub depth_test: bool,
    pub depth_write: bool,
    pub depth_compare_op: CompareOp,
    pub depth_bias_constant: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope: f32,
    pub depth_bounds_test: bool,
    pub stencil: StencilState,
    pub shading_rate: bool,
    pub wireframe: bool,
    pub view_mask: u32,
    pub vertex_layout: *const VertexLayoutElement,
    pub vertex_layout_count: i32,
    pub vertex_stride: i32,
    pub vs_entry_point: *const c_char,
    pub ps_entry_point: *const c_char,
}
impl Default for PipelineDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputePipelineDesc {
    pub shader: Shader,
    pub entry_point: *const c_char,
}
impl Default for ComputePipelineDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpuTimestamp {
    pub name: *const c_char,
    pub microseconds: f32,
}
impl Default for GpuTimestamp {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryTriangles {
    pub vertex_buffer: Buffer,
    pub vertex_offset: u64,
    pub vertex_count: u32,
    pub vertex_stride: u32,
    pub vertex_format: Format,
    pub index_buffer: Buffer,
    pub index_offset: u64,
    pub index_count: u32,
    pub index_type: IndexType,
    pub transform_buffer: Buffer,
    pub transform_offset: u64,
    pub micromap: Micromap,
    pub micromap_index_buffer: Buffer,
    pub micromap_index_offset: u64,
    pub micromap_index_type: IndexType,
    pub micromap_base_triangle: u32,
}
impl Default for GeometryTriangles {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryAABBs {
    pub aabb_buffer: Buffer,
    pub offset: u64,
    pub count: u32,
    pub stride: u32,
}
impl Default for GeometryAABBs {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryDesc_Data {
    pub triangles: GeometryTriangles,
    pub aabbs: GeometryAABBs,
}
impl Default for GeometryDesc_Data {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GeometryDesc {
    pub is_aabb: bool,
    pub opaque: bool,
    pub data: GeometryDesc_Data,
}
impl Default for GeometryDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelerationStructureDesc {
    pub r#type: AccelerationStructureType,
    pub flags: BuildASFlags,
    pub count: u32,
    pub geometries: *const GeometryDesc,
}
impl Default for AccelerationStructureDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Instance {
    pub transform: [[f32; 4]; 3],
    pub instance_id: u32,
    pub mask: u32,
    pub instance_contribution_to_hit_group_index: u32,
    pub flags: InstanceFlags,
    pub blas: AccelerationStructure,
}
impl Default for Instance {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderGroup {
    pub r#type: ShaderGroupType,
    pub general_shader: *const c_char,
    pub closest_hit_shader: *const c_char,
    pub any_hit_shader: *const c_char,
    pub intersection_shader: *const c_char,
}
impl Default for ShaderGroup {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingPipelineDesc {
    pub shader: Shader,
    pub groups: *const ShaderGroup,
    pub group_count: u32,
    pub max_recursion_depth: u32,
    pub max_payload_size: u32,
    pub max_attribute_size: u32,
    pub flags: RayTracingPipelineFlags,
}
impl Default for RayTracingPipelineDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TraceRaysDesc {
    pub sbt: ShaderBindingTable,
    pub ray_gen_index: u32,
    pub miss_index: u32,
    pub miss_count: u32,
    pub hit_index: u32,
    pub hit_count: u32,
    pub callable_index: u32,
    pub callable_count: u32,
}
impl Default for TraceRaysDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextureDesc {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub format: Format,
    pub sample_count: i32,
    pub usage: TextureUsageFlags,
    pub initial_data: *const c_void,
}
impl Default for TextureDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MicromapUsage {
    pub count: u32,
    pub subdivision_level: u16,
    pub format: MicromapFormat,
}
impl Default for MicromapUsage {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MicromapDesc {
    pub usages: *const MicromapUsage,
    pub usage_count: u32,
    pub flags: BuildMicromapFlags,
}
impl Default for MicromapDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BuildMicromapDesc {
    pub dst: Micromap,
    pub data: Buffer,
    pub data_offset: u64,
    pub triangle_indices: Buffer,
    pub triangle_indices_offset: u64,
    pub scratch: Buffer,
    pub scratch_offset: u64,
}
impl Default for BuildMicromapDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpscalerDesc {
    pub r#type: UpscalerType,
    pub mode: UpscalerMode,
    pub flags: UpscalerFlags,
    pub output_width: u32,
    pub output_height: u32,
    pub preset: u8,
}
impl Default for UpscalerDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpscalerProps {
    pub scaling_factor: f32,
    pub mip_bias: f32,
    pub render_width: u32,
    pub render_height: u32,
    pub output_width: u32,
    pub output_height: u32,
    pub jitter_phase_count: u8,
}
impl Default for UpscalerProps {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpscaleDesc {
    pub input: Texture,
    pub output: Texture,
    pub depth: Texture,
    pub motion_vectors: Texture,
    pub exposure: Texture,
    pub reactive: Texture,
    pub normal_roughness: Texture,
    pub diffuse_albedo: Texture,
    pub specular_albedo: Texture,
    pub specular_mv_or_hit_t: Texture,
    pub sss: Texture,
    pub sharpness: f32,
    pub jitter: [f32; 2],
    pub motion_vector_scale: [f32; 2],
    pub dispatch_flags: UpscaleDispatchFlags,
    pub z_near: f32,
    pub z_far: f32,
    pub vertical_fov: f32,
    pub view_space_to_meters_factor: f32,
    pub view_to_clip: [f32; 16],
    pub world_to_view: [f32; 16],
}
impl Default for UpscaleDesc {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleLocation {
    pub x: i8,
    pub y: i8,
}
impl Default for SampleLocation {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LatencyReport {
    pub input_sample_time_us: u64,
    pub simulation_start_time_us: u64,
    pub simulation_end_time_us: u64,
    pub render_submit_start_time_us: u64,
    pub render_submit_end_time_us: u64,
    pub present_start_time_us: u64,
    pub present_end_time_us: u64,
    pub driver_start_time_us: u64,
    pub driver_end_time_us: u64,
    pub os_render_queue_start_time_us: u64,
    pub os_render_queue_end_time_us: u64,
    pub gpu_render_start_time_us: u64,
    pub gpu_render_end_time_us: u64,
}
impl Default for LatencyReport {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiDrawData {
    pub draw_lists: *const c_void,
    pub draw_list_count: u32,
    pub textures: *const c_void,
    pub texture_count: u32,
    pub display_width: f32,
    pub display_height: f32,
    pub hdr_scale: f32,
    pub linear_color: bool,
}
impl Default for ImGuiDrawData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

//
// Functions
//
impl AccelerationStructure {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyAccelerationStructure(self.0) }
    }
    pub fn get_id(&self) -> u32 {
        unsafe { sys::rfxGetAccelerationStructureId(self.0) }
    }
    pub fn get_scratch_size(&self) -> u64 {
        unsafe { sys::rfxGetAccelerationStructureScratchSize(self.0) }
    }
}
impl Buffer {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyBuffer(self.0) }
    }
    pub fn map(&self) -> *mut c_void {
        unsafe { sys::rfxMapBuffer(self.0) }
    }
    pub fn unmap(&self) {
        unsafe { sys::rfxUnmapBuffer(self.0) }
    }
    pub fn get_id(&self) -> u32 {
        unsafe { sys::rfxGetBufferId(self.0) }
    }
    pub fn set_name(&self, name: &str) {
        unsafe { sys::rfxSetBufferName(self.0, std::ffi::CString::new(name).unwrap().as_ptr()) }
    }
}
impl CommandList {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyCommandList(self.0) }
    }
    pub fn begin(&self) {
        unsafe { sys::rfxBeginCommandList(self.0) }
    }
    pub fn end(&self) {
        unsafe { sys::rfxEndCommandList(self.0) }
    }
    pub fn submit_async(
        &self,
        wait_fences: *mut Fence,
        wait_values: *mut u64,
        wait_count: u32,
        signal_fences: *mut Fence,
        signal_values: *mut u64,
        signal_count: u32,
    ) {
        unsafe {
            sys::rfxSubmitCommandListAsync(
                self.0,
                wait_fences as *mut sys::RfxFence,
                wait_values as *mut u64,
                wait_count,
                signal_fences as *mut sys::RfxFence,
                signal_values as *mut u64,
                signal_count,
            )
        }
    }
    pub fn begin_swapchain_render_pass(&self, depth_stencil_format: Format, clear_color: Color) {
        unsafe {
            sys::rfxCmdBeginSwapchainRenderPass(
                self.0,
                unsafe { std::mem::transmute(depth_stencil_format) },
                unsafe { std::mem::transmute(clear_color) },
            )
        }
    }
    pub fn begin_render_pass(
        &self,
        colors: *mut Texture,
        color_count: u32,
        depth: Texture,
        clear_color: Color,
        view_mask: u32,
    ) {
        unsafe {
            sys::rfxCmdBeginRenderPass(
                self.0,
                colors as *mut sys::RfxTexture,
                color_count,
                depth.0,
                unsafe { std::mem::transmute(clear_color) },
                view_mask,
            )
        }
    }
    pub fn end_render_pass(&self) {
        unsafe { sys::rfxCmdEndRenderPass(self.0) }
    }
    pub fn clear(&self, color: Color) {
        unsafe { sys::rfxCmdClear(self.0, unsafe { std::mem::transmute(color) }) }
    }
    pub fn bind_pipeline(&self, pipeline: Pipeline) {
        unsafe { sys::rfxCmdBindPipeline(self.0, pipeline.0) }
    }
    pub fn set_viewports(&self, viewports: *mut f32, count: u32) {
        unsafe { sys::rfxCmdSetViewports(self.0, viewports as *mut f32, count) }
    }
    pub fn set_scissor(&self, x: i32, y: i32, width: i32, height: i32) {
        unsafe { sys::rfxCmdSetScissor(self.0, x, y, width, height) }
    }
    pub fn set_blend_constants(&self, color: Color) {
        unsafe { sys::rfxCmdSetBlendConstants(self.0, unsafe { std::mem::transmute(color) }) }
    }
    pub fn set_stencil_reference(&self, front_ref: u8, back_ref: u8) {
        unsafe { sys::rfxCmdSetStencilReference(self.0, front_ref, back_ref) }
    }
    pub fn set_depth_bounds(&self, min_bound: f32, max_bound: f32) {
        unsafe { sys::rfxCmdSetDepthBounds(self.0, min_bound, max_bound) }
    }
    pub fn set_depth_bias(&self, constant: f32, clamp: f32, slope: f32) {
        unsafe { sys::rfxCmdSetDepthBias(self.0, constant, clamp, slope) }
    }
    pub fn set_shading_rate(
        &self,
        rate: ShadingRate,
        primitive_combiner: ShadingRateCombiner,
        attachment_combiner: ShadingRateCombiner,
    ) {
        unsafe {
            sys::rfxCmdSetShadingRate(
                self.0,
                unsafe { std::mem::transmute(rate) },
                unsafe { std::mem::transmute(primitive_combiner) },
                unsafe { std::mem::transmute(attachment_combiner) },
            )
        }
    }
    pub fn set_sample_locations(
        &self,
        locations: *mut SampleLocation,
        location_count: u32,
        sample_count: u32,
    ) {
        unsafe {
            sys::rfxCmdSetSampleLocations(
                self.0,
                locations as *mut sys::RfxSampleLocation,
                location_count,
                sample_count,
            )
        }
    }
    pub fn bind_vertex_buffer(&self, buffer: Buffer) {
        unsafe { sys::rfxCmdBindVertexBuffer(self.0, buffer.0) }
    }
    pub fn bind_index_buffer(&self, buffer: Buffer, index_type: IndexType) {
        unsafe {
            sys::rfxCmdBindIndexBuffer(self.0, buffer.0, unsafe { std::mem::transmute(index_type) })
        }
    }
    pub fn push_constants(&self, data: *mut c_void, size: usize) {
        unsafe { sys::rfxCmdPushConstants(self.0, data as *mut c_void, size) }
    }
    pub fn draw(&self, vertex_count: u32, instance_count: u32) {
        unsafe { sys::rfxCmdDraw(self.0, vertex_count, instance_count) }
    }
    pub fn draw_indexed(&self, index_count: u32, instance_count: u32) {
        unsafe { sys::rfxCmdDrawIndexed(self.0, index_count, instance_count) }
    }
    pub fn dispatch(&self, x: u32, y: u32, z: u32) {
        unsafe { sys::rfxCmdDispatch(self.0, x, y, z) }
    }
    pub fn draw_indirect(&self, buffer: Buffer, offset: usize, draw_count: u32, stride: u32) {
        unsafe { sys::rfxCmdDrawIndirect(self.0, buffer.0, offset, draw_count, stride) }
    }
    pub fn draw_indexed_indirect(
        &self,
        buffer: Buffer,
        offset: usize,
        draw_count: u32,
        stride: u32,
    ) {
        unsafe { sys::rfxCmdDrawIndexedIndirect(self.0, buffer.0, offset, draw_count, stride) }
    }
    pub fn dispatch_indirect(&self, buffer: Buffer, offset: usize) {
        unsafe { sys::rfxCmdDispatchIndirect(self.0, buffer.0, offset) }
    }
    pub fn draw_mesh_tasks(&self, x: u32, y: u32, z: u32) {
        unsafe { sys::rfxCmdDrawMeshTasks(self.0, x, y, z) }
    }
    pub fn draw_mesh_tasks_indirect(
        &self,
        buffer: Buffer,
        offset: usize,
        draw_count: u32,
        stride: u32,
    ) {
        unsafe { sys::rfxCmdDrawMeshTasksIndirect(self.0, buffer.0, offset, draw_count, stride) }
    }
    pub fn draw_indirect_count(
        &self,
        buffer: Buffer,
        offset: usize,
        count_buffer: Buffer,
        count_buffer_offset: usize,
        max_draw_count: u32,
        stride: u32,
    ) {
        unsafe {
            sys::rfxCmdDrawIndirectCount(
                self.0,
                buffer.0,
                offset,
                count_buffer.0,
                count_buffer_offset,
                max_draw_count,
                stride,
            )
        }
    }
    pub fn draw_indexed_indirect_count(
        &self,
        buffer: Buffer,
        offset: usize,
        count_buffer: Buffer,
        count_buffer_offset: usize,
        max_draw_count: u32,
        stride: u32,
    ) {
        unsafe {
            sys::rfxCmdDrawIndexedIndirectCount(
                self.0,
                buffer.0,
                offset,
                count_buffer.0,
                count_buffer_offset,
                max_draw_count,
                stride,
            )
        }
    }
    pub fn draw_mesh_tasks_indirect_count(
        &self,
        buffer: Buffer,
        offset: usize,
        count_buffer: Buffer,
        count_buffer_offset: usize,
        max_draw_count: u32,
        stride: u32,
    ) {
        unsafe {
            sys::rfxCmdDrawMeshTasksIndirectCount(
                self.0,
                buffer.0,
                offset,
                count_buffer.0,
                count_buffer_offset,
                max_draw_count,
                stride,
            )
        }
    }
    pub fn copy_buffer(
        &self,
        src: Buffer,
        src_offset: usize,
        dst: Buffer,
        dst_offset: usize,
        size: usize,
    ) {
        unsafe { sys::rfxCmdCopyBuffer(self.0, src.0, src_offset, dst.0, dst_offset, size) }
    }
    pub fn copy_texture(&self, src: Texture, dst: Texture) {
        unsafe { sys::rfxCmdCopyTexture(self.0, src.0, dst.0) }
    }
    pub fn upload_texture(&self, dst: Texture, data: *mut c_void, mip: u32, layer: u32) {
        unsafe { sys::rfxCmdUploadTexture(self.0, dst.0, data as *mut c_void, mip, layer) }
    }
    pub fn readback_texture_to_buffer(&self, src: Texture, dst: Buffer, dst_offset: u64) {
        unsafe { sys::rfxCmdReadbackTextureToBuffer(self.0, src.0, dst.0, dst_offset) }
    }
    pub fn zero_buffer(&self, buffer: Buffer, offset: usize, size: usize) {
        unsafe { sys::rfxCmdZeroBuffer(self.0, buffer.0, offset, size) }
    }
    pub fn clear_storage_buffer(&self, buffer: Buffer, value: u32) {
        unsafe { sys::rfxCmdClearStorageBuffer(self.0, buffer.0, value) }
    }
    pub fn clear_storage_texture(&self, texture: Texture, value: Color) {
        unsafe {
            sys::rfxCmdClearStorageTexture(self.0, texture.0, unsafe { std::mem::transmute(value) })
        }
    }
    pub fn resolve_texture(&self, dst: Texture, src: Texture, op: ResolveOp) {
        unsafe {
            sys::rfxCmdResolveTexture(self.0, dst.0, src.0, unsafe { std::mem::transmute(op) })
        }
    }
    pub fn copy_micromap(&self, dst: Micromap, src: Micromap, mode: CopyMode) {
        unsafe {
            sys::rfxCmdCopyMicromap(self.0, dst.0, src.0, unsafe { std::mem::transmute(mode) })
        }
    }
    pub fn copy_acceleration_structure(
        &self,
        dst: AccelerationStructure,
        src: AccelerationStructure,
        mode: CopyMode,
    ) {
        unsafe {
            sys::rfxCmdCopyAccelerationStructure(self.0, dst.0, src.0, unsafe {
                std::mem::transmute(mode)
            })
        }
    }
    pub fn transition_buffer(&self, buffer: Buffer, state: ResourceState) {
        unsafe {
            sys::rfxCmdTransitionBuffer(self.0, buffer.0, unsafe { std::mem::transmute(state) })
        }
    }
    pub fn transition_texture(&self, texture: Texture, state: ResourceState) {
        unsafe {
            sys::rfxCmdTransitionTexture(self.0, texture.0, unsafe { std::mem::transmute(state) })
        }
    }
    pub fn begin_event(&self, name: &str) {
        unsafe { sys::rfxCmdBeginEvent(self.0, std::ffi::CString::new(name).unwrap().as_ptr()) }
    }
    pub fn end_event(&self) {
        unsafe { sys::rfxCmdEndEvent(self.0) }
    }
    pub fn marker(&self, name: &str) {
        unsafe { sys::rfxCmdMarker(self.0, std::ffi::CString::new(name).unwrap().as_ptr()) }
    }
    pub fn begin_profile(&self, name: &str) {
        unsafe { sys::rfxCmdBeginProfile(self.0, std::ffi::CString::new(name).unwrap().as_ptr()) }
    }
    pub fn end_profile(&self) {
        unsafe { sys::rfxCmdEndProfile(self.0) }
    }
    pub fn reset_queries(&self, pool: QueryPool, offset: u32, count: u32) {
        unsafe { sys::rfxCmdResetQueries(self.0, pool.0, offset, count) }
    }
    pub fn begin_query(&self, pool: QueryPool, query_index: u32) {
        unsafe { sys::rfxCmdBeginQuery(self.0, pool.0, query_index) }
    }
    pub fn end_query(&self, pool: QueryPool, query_index: u32) {
        unsafe { sys::rfxCmdEndQuery(self.0, pool.0, query_index) }
    }
    pub fn copy_queries(
        &self,
        pool: QueryPool,
        offset: u32,
        count: u32,
        dst_buffer: Buffer,
        dst_offset: u64,
    ) {
        unsafe { sys::rfxCmdCopyQueries(self.0, pool.0, offset, count, dst_buffer.0, dst_offset) }
    }
    pub fn draw_im_gui(&self, data: *mut ImGuiDrawData) {
        unsafe { sys::rfxCmdDrawImGui(self.0, data as *mut sys::RfxImGuiDrawData) }
    }
    pub fn denoise(
        &self,
        denoiser: Denoiser,
        settings: *mut DenoiserSettings,
        resources: *mut Texture,
        resource_count: u32,
    ) {
        unsafe {
            sys::rfxCmdDenoise(
                self.0,
                denoiser.0,
                settings as *mut sys::RfxDenoiserSettings,
                resources as *mut sys::RfxTexture,
                resource_count,
            )
        }
    }
    pub fn write_acceleration_structure_size(
        &self,
        as_array: *mut AccelerationStructure,
        count: u32,
        pool: QueryPool,
        query_offset: u32,
    ) {
        unsafe {
            sys::rfxCmdWriteAccelerationStructureSize(
                self.0,
                as_array as *mut sys::RfxAccelerationStructure,
                count,
                pool.0,
                query_offset,
            )
        }
    }
    pub fn build_acceleration_structure(
        &self,
        dst: AccelerationStructure,
        scratch: Buffer,
        instance_buffer: Buffer,
    ) {
        unsafe {
            sys::rfxCmdBuildAccelerationStructure(self.0, dst.0, scratch.0, instance_buffer.0)
        }
    }
    pub fn upload_instances(
        &self,
        dst_buffer: Buffer,
        instances: *mut Instance,
        instance_count: u32,
    ) {
        unsafe {
            sys::rfxCmdUploadInstances(
                self.0,
                dst_buffer.0,
                instances as *mut sys::RfxInstance,
                instance_count,
            )
        }
    }
    pub fn trace_rays(&self, desc: *mut TraceRaysDesc, width: u32, height: u32, depth: u32) {
        unsafe {
            sys::rfxCmdTraceRays(
                self.0,
                desc as *mut sys::RfxTraceRaysDesc,
                width,
                height,
                depth,
            )
        }
    }
    pub fn dispatch_rays_indirect(
        &self,
        desc: *mut TraceRaysDesc,
        args_buffer: Buffer,
        args_offset: u64,
    ) {
        unsafe {
            sys::rfxCmdDispatchRaysIndirect(
                self.0,
                desc as *mut sys::RfxTraceRaysDesc,
                args_buffer.0,
                args_offset,
            )
        }
    }
    pub fn build_micromaps(&self, desc: *mut BuildMicromapDesc) {
        unsafe { sys::rfxCmdBuildMicromaps(self.0, desc as *mut sys::RfxBuildMicromapDesc) }
    }
    pub fn upscale(&self, upscaler: Upscaler, desc: *mut UpscaleDesc) {
        unsafe { sys::rfxCmdUpscale(self.0, upscaler.0, desc as *mut sys::RfxUpscaleDesc) }
    }
}
impl Denoiser {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyDenoiser(self.0) }
    }
}
impl Fence {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyFence(self.0) }
    }
    pub fn wait(&self, value: u64) {
        unsafe { sys::rfxWaitFence(self.0, value) }
    }
    pub fn get_value(&self) -> u64 {
        unsafe { sys::rfxGetFenceValue(self.0) }
    }
}
impl Micromap {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyMicromap(self.0) }
    }
    pub fn get_scratch_size(&self) -> u64 {
        unsafe { sys::rfxGetMicromapScratchSize(self.0) }
    }
}
impl Pipeline {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyPipeline(self.0) }
    }
    pub fn set_name(&self, name: &str) {
        unsafe { sys::rfxSetPipelineName(self.0, std::ffi::CString::new(name).unwrap().as_ptr()) }
    }
    pub fn create_shader_binding_table(&self) -> ShaderBindingTable {
        ShaderBindingTable(unsafe { sys::rfxCreateShaderBindingTable(self.0) })
    }
}
impl QueryPool {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyQueryPool(self.0) }
    }
}
impl Sampler {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroySampler(self.0) }
    }
}
impl Shader {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyShader(self.0) }
    }
}
impl ShaderBindingTable {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyShaderBindingTable(self.0) }
    }
}
impl Texture {
    pub fn create_view(
        &self,
        format: Format,
        mip: u32,
        mip_count: u32,
        layer: u32,
        layer_count: u32,
    ) -> Texture {
        Texture(unsafe {
            sys::rfxCreateTextureView(
                self.0,
                unsafe { std::mem::transmute(format) },
                mip,
                mip_count,
                layer,
                layer_count,
            )
        })
    }
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyTexture(self.0) }
    }
    pub fn get_id(&self) -> u32 {
        unsafe { sys::rfxGetTextureId(self.0) }
    }
    pub fn get_descriptor(&self) -> *mut c_void {
        unsafe { sys::rfxGetTextureDescriptor(self.0) }
    }
    pub fn set_name(&self, name: &str) {
        unsafe { sys::rfxSetTextureName(self.0, std::ffi::CString::new(name).unwrap().as_ptr()) }
    }
}
impl Upscaler {
    pub fn destroy(&self) {
        unsafe { sys::rfxDestroyUpscaler(self.0) }
    }
    pub fn get_props(&self, out_props: *mut UpscalerProps) {
        unsafe { sys::rfxGetUpscalerProps(self.0, out_props as *mut sys::RfxUpscalerProps) }
    }
}
pub fn request_backend(backend: Backend, enable_validation: bool) {
    unsafe { sys::rfxRequestBackend(unsafe { std::mem::transmute(backend) }, enable_validation) }
}
pub fn open_window(title: &str, width: i32, height: i32) -> bool {
    unsafe {
        sys::rfxOpenWindow(
            std::ffi::CString::new(title).unwrap().as_ptr(),
            width,
            height,
        )
    }
}
pub fn supports_features(features: FeatureSupportFlags) -> bool {
    unsafe { sys::rfxSupportsFeatures(unsafe { std::mem::transmute(features) }) }
}
pub fn get_supported_features() -> FeatureSupportFlags {
    unsafe { std::mem::transmute(unsafe { sys::rfxGetSupportedFeatures() }) }
}
pub fn set_sample_count(count: i32) {
    unsafe { sys::rfxSetSampleCount(count) }
}
pub fn set_anisotropy(level: i32) {
    unsafe { sys::rfxSetAnisotropy(level) }
}
pub fn set_window_flags(flags: WindowFlags) {
    unsafe { sys::rfxSetWindowFlags(unsafe { std::mem::transmute(flags) }) }
}
pub fn enable_window_flags(flags: WindowFlags) {
    unsafe { sys::rfxEnableWindowFlags(unsafe { std::mem::transmute(flags) }) }
}
pub fn disable_window_flags(flags: WindowFlags) {
    unsafe { sys::rfxDisableWindowFlags(unsafe { std::mem::transmute(flags) }) }
}
pub fn toggle_window_flags(flags: WindowFlags) {
    unsafe { sys::rfxToggleWindowFlags(unsafe { std::mem::transmute(flags) }) }
}
pub fn has_window_flags(flags: WindowFlags) -> bool {
    unsafe { sys::rfxHasWindowFlags(unsafe { std::mem::transmute(flags) }) }
}
pub fn window_should_close() -> bool {
    unsafe { sys::rfxWindowShouldClose() }
}
pub fn poll_input_events() {
    unsafe { sys::rfxPollInputEvents() }
}
pub fn get_window_size(width: *mut i32, height: *mut i32) {
    unsafe { sys::rfxGetWindowSize(width as *mut i32, height as *mut i32) }
}
pub fn get_window_width() -> i32 {
    unsafe { sys::rfxGetWindowWidth() }
}
pub fn get_window_height() -> i32 {
    unsafe { sys::rfxGetWindowHeight() }
}
pub fn get_time() -> f64 {
    unsafe { sys::rfxGetTime() }
}
pub fn get_delta_time() -> f32 {
    unsafe { sys::rfxGetDeltaTime() }
}
pub fn get_frame_index() -> u32 {
    unsafe { sys::rfxGetFrameIndex() }
}
pub fn is_key_down(key: Key) -> bool {
    unsafe { sys::rfxIsKeyDown(unsafe { std::mem::transmute(key) }) }
}
pub fn is_key_pressed(key: Key) -> bool {
    unsafe { sys::rfxIsKeyPressed(unsafe { std::mem::transmute(key) }) }
}
pub fn is_key_released(key: Key) -> bool {
    unsafe { sys::rfxIsKeyReleased(unsafe { std::mem::transmute(key) }) }
}
pub fn is_mouse_button_down(button: MouseButton) -> bool {
    unsafe { sys::rfxIsMouseButtonDown(unsafe { std::mem::transmute(button) }) }
}
pub fn is_mouse_button_pressed(button: MouseButton) -> bool {
    unsafe { sys::rfxIsMouseButtonPressed(unsafe { std::mem::transmute(button) }) }
}
pub fn is_mouse_button_released(button: MouseButton) -> bool {
    unsafe { sys::rfxIsMouseButtonReleased(unsafe { std::mem::transmute(button) }) }
}
pub fn get_mouse_pos(x: *mut f32, y: *mut f32) {
    unsafe { sys::rfxGetMousePos(x as *mut f32, y as *mut f32) }
}
pub fn get_mouse_delta(x: *mut f32, y: *mut f32) {
    unsafe { sys::rfxGetMouseDelta(x as *mut f32, y as *mut f32) }
}
pub fn set_mouse_cursor_visible(visible: bool) {
    unsafe { sys::rfxSetMouseCursorVisible(visible) }
}
pub fn set_mouse_cursor(cursor: CursorType) {
    unsafe { sys::rfxSetMouseCursor(unsafe { std::mem::transmute(cursor) }) }
}
pub fn create_buffer(
    size: usize,
    stride: usize,
    usage: BufferUsageFlags,
    mem_type: MemoryType,
    initial_data: *mut c_void,
) -> Buffer {
    Buffer(unsafe {
        sys::rfxCreateBuffer(
            size,
            stride,
            unsafe { std::mem::transmute(usage) },
            unsafe { std::mem::transmute(mem_type) },
            initial_data as *mut c_void,
        )
    })
}
pub fn create_texture(
    width: i32,
    height: i32,
    format: Format,
    sample_count: i32,
    usage: TextureUsageFlags,
    initial_data: *mut c_void,
) -> Texture {
    Texture(unsafe {
        sys::rfxCreateTexture(
            width,
            height,
            unsafe { std::mem::transmute(format) },
            sample_count,
            unsafe { std::mem::transmute(usage) },
            initial_data as *mut c_void,
        )
    })
}
pub fn create_texture_ex(desc: *mut TextureDesc) -> Texture {
    Texture(unsafe { sys::rfxCreateTextureEx(desc as *mut sys::RfxTextureDesc) })
}
pub fn get_swap_chain_format() -> Format {
    unsafe { std::mem::transmute(unsafe { sys::rfxGetSwapChainFormat() }) }
}
pub fn get_backbuffer_texture() -> Texture {
    Texture(unsafe { sys::rfxGetBackbufferTexture() })
}
pub fn create_sampler(filter: Filter, address_mode: AddressMode) -> Sampler {
    Sampler(unsafe {
        sys::rfxCreateSampler(unsafe { std::mem::transmute(filter) }, unsafe {
            std::mem::transmute(address_mode)
        })
    })
}
pub fn compile_shader(
    filepath: &str,
    defines: &str,
    num_defines: i32,
    include_dirs: &str,
    num_include_dirs: i32,
) -> Shader {
    Shader(unsafe {
        sys::rfxCompileShader(
            std::ffi::CString::new(filepath).unwrap().as_ptr(),
            std::ffi::CString::new(defines).unwrap().as_ptr(),
            num_defines,
            std::ffi::CString::new(include_dirs).unwrap().as_ptr(),
            num_include_dirs,
        )
    })
}
pub fn compile_shader_mem(
    source: &str,
    defines: &str,
    num_defines: i32,
    include_dirs: &str,
    num_include_dirs: i32,
) -> Shader {
    Shader(unsafe {
        sys::rfxCompileShaderMem(
            std::ffi::CString::new(source).unwrap().as_ptr(),
            std::ffi::CString::new(defines).unwrap().as_ptr(),
            num_defines,
            std::ffi::CString::new(include_dirs).unwrap().as_ptr(),
            num_include_dirs,
        )
    })
}
pub fn create_pipeline(desc: *mut PipelineDesc) -> Pipeline {
    Pipeline(unsafe { sys::rfxCreatePipeline(desc as *mut sys::RfxPipelineDesc) })
}
pub fn create_compute_pipeline(desc: *mut ComputePipelineDesc) -> Pipeline {
    Pipeline(unsafe { sys::rfxCreateComputePipeline(desc as *mut sys::RfxComputePipelineDesc) })
}
pub fn get_command_list() -> CommandList {
    CommandList(unsafe { sys::rfxGetCommandList() })
}
pub fn create_command_list(queue_type: QueueType) -> CommandList {
    CommandList(unsafe { sys::rfxCreateCommandList(unsafe { std::mem::transmute(queue_type) }) })
}
pub fn begin_frame() {
    unsafe { sys::rfxBeginFrame() }
}
pub fn end_frame() {
    unsafe { sys::rfxEndFrame() }
}
pub fn create_fence(initial_value: u64) -> Fence {
    Fence(unsafe { sys::rfxCreateFence(initial_value) })
}
pub fn begin_event(name: &str) {
    unsafe { sys::rfxBeginEvent(std::ffi::CString::new(name).unwrap().as_ptr()) }
}
pub fn end_event() {
    unsafe { sys::rfxEndEvent() }
}
pub fn marker(name: &str) {
    unsafe { sys::rfxMarker(std::ffi::CString::new(name).unwrap().as_ptr()) }
}
pub fn get_gpu_timestamps(out_timestamps: *mut GpuTimestamp, max_count: u32) -> u32 {
    unsafe { sys::rfxGetGpuTimestamps(out_timestamps as *mut sys::RfxGpuTimestamp, max_count) }
}
pub fn create_query_pool(r#type: QueryType, capacity: u32) -> QueryPool {
    QueryPool(unsafe { sys::rfxCreateQueryPool(unsafe { std::mem::transmute(r#type) }, capacity) })
}
pub fn set_low_latency_mode(enabled: bool, boost: bool) {
    unsafe { sys::rfxSetLowLatencyMode(enabled, boost) }
}
pub fn latency_sleep() {
    unsafe { sys::rfxLatencySleep() }
}
pub fn set_latency_marker(marker: LatencyMarker) {
    unsafe { sys::rfxSetLatencyMarker(unsafe { std::mem::transmute(marker) }) }
}
pub fn get_latency_report(out_report: *mut LatencyReport) -> bool {
    unsafe { sys::rfxGetLatencyReport(out_report as *mut sys::RfxLatencyReport) }
}
pub fn init_im_gui() -> bool {
    unsafe { sys::rfxInitImGui() }
}
pub fn shutdown_im_gui() {
    unsafe { sys::rfxShutdownImGui() }
}
pub fn create_denoiser(r#type: DenoiserType, width: i32, height: i32) -> Denoiser {
    Denoiser(unsafe {
        sys::rfxCreateDenoiser(unsafe { std::mem::transmute(r#type) }, width, height)
    })
}
pub fn create_acceleration_structure(
    desc: *mut AccelerationStructureDesc,
) -> AccelerationStructure {
    AccelerationStructure(unsafe {
        sys::rfxCreateAccelerationStructure(desc as *mut sys::RfxAccelerationStructureDesc)
    })
}
pub fn create_ray_tracing_pipeline(desc: *mut RayTracingPipelineDesc) -> Pipeline {
    Pipeline(unsafe {
        sys::rfxCreateRayTracingPipeline(desc as *mut sys::RfxRayTracingPipelineDesc)
    })
}
pub fn create_micromap(desc: *mut MicromapDesc) -> Micromap {
    Micromap(unsafe { sys::rfxCreateMicromap(desc as *mut sys::RfxMicromapDesc) })
}
pub fn is_upscaler_supported(r#type: UpscalerType) -> bool {
    unsafe { sys::rfxIsUpscalerSupported(unsafe { std::mem::transmute(r#type) }) }
}
pub fn create_upscaler(desc: *mut UpscalerDesc) -> Upscaler {
    Upscaler(unsafe { sys::rfxCreateUpscaler(desc as *mut sys::RfxUpscalerDesc) })
}
